#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
using namespace std;

//goto语句 - C一样
//作用 - 可以无条件跳转语句
//语法：goto 标记;
//解释如果标记的名称存在在，执行goto语句时，会跳转到标记的位置
//注意:在程序中不建议使用goto语句，以免造成程序流程混乱

//int main()
//{
//	//goto语句
//	cout << "1.XXXX" << endl;
//	cout << "2.XXXX" << endl;
//	goto FALG;
//	cout << "3.XXXX" << endl;
//	cout << "4.XXXX" << endl;
//	FALG:
//	cout << "5.XXXX" << endl;
//
//	system("pause");
//	return 0;
//}

//数组 - C一样
//概述：所谓的数组，就是一个集合，里面存放了相同类型的数据元素
// 特点1：数组中的每个数据元素都是相同的数据类型
// 特点2：数组是由连续的内存位置组成的
// 一维数组的三种定义方式
// 数据类型 数组名[数组长度];
// 数据类型 数组名[数组长度] = {值1, 值2, ...};
// 数据类型 数组名[] = {值1, 值2 ...};
//定义数组的时候，必须由初始长度或初始值
//总结1 - 数组名的命名规范与变量命名规范一致，不要和变量重名
//总结2 - 数组中下标是从0开始索引的

//一维数组的数组名 - C一样
//用途
// 可以统计整个数组在内存中的长度 - sizeof(数组名)
// 可以获取数组在内存中的首地址
//数组名是一个常量，不可以进行赋值的操作，这个名字已经指向这个数组了

//int main()
//{
//	//数组名的用途
//	// 可以统计整个数组在内存中的长度
//	int arr[] = { 1,2,3,4,5,6 };
//	cout <<"整个数组在内存中长度 = " << sizeof(arr) << endl;
//	cout << "一个数组元素在内存中长度 = " << sizeof(arr[0]) << endl;
//	cout << "数组长度 = " << sizeof(arr) / sizeof(arr[0]) << endl;
//
//	// 可以获取数组在内存中的首地址
//	cout << "数组的首地址 = " << arr << endl;
//	cout << "数组的第一个元素地址 = " << &arr[0] << endl;//取地址符号你不会不知道吧，
//	cout << "数组的第二个元素地址 = " << &arr[1] << endl;
//
//	system("pause");
//	return 0;
//}

//案列1 - 5只小猪称体重 - 谁重
//案列2 - 数组元素逆序

//int main()
//{
//	//小猪体重 - 找最大值 - 这么基础的就不用写注释了吧，我一般不会的就写注释
//	int arr[] = { 1,2,3,4,5,6 };
//	int len = sizeof(arr) / sizeof(arr[0]);
//	int max = 0;
//	for (int i = 0; i < len; i++)
//	{
//		(max > arr[i]) ? NULL : max = arr[i];
//		//if (max < arr[i])
//		//{
//		//	max = arr[i];
//		//}
//	}
//	cout << max << endl;
//
//	printf("\n");
//
//	//数组逆序
//	int low = 0;
//	int fast = len - 1;
//	while (fast > low)
//	{
//		int n = 0;
//		n = arr[low];
//		arr[low] = arr[fast];
//		arr[fast] = n;
//		fast--;
//		low++;
//	}
//	for (int j = 0; j < len; j++)
//	{
//		cout << arr[j] << endl;
//	}
//	
//	system("pause");
//	return 0;
//}

//冒泡排序 - 还是快排比较好
//最常用的排序算法，对数组内元素进行排序
//1.比较相邻的元素，如果第一个比第二个大，就交换他们两个
//2.对每一对相邻元素做同样的工作，执行完后找到第一个最大值
//3.重复以上的步骤，每次比较次数-1，直到不需要比较

//int main()
//{
//	int arr[] = { 1,3,5,7,2,4,6,8 };
//	int len = sizeof(arr) / sizeof(arr[0]);
//	for (int i = 0; i < len; i++)
//	{
//		for (int j = i+1; j < len; j++)
//		{
//			if (arr[i] > arr[j])
//			{
//				int n = arr[i];
//				arr[i] = arr[j];
//				arr[j] = n;
//			}
//		}
//	}
//	for (int z = 0; z < len; z++)
//	{
//		printf("%d\n", arr[z]);
//	}
//
//	system("pause");
//	return 0;
//}

//二维数组
//就是在一维数组上，多加一个维度。
// 4种定义方式
// 数据类型 数组名[行数][列数];
// 数据类型 数组名[行数][列数] = {{数据1，数据2}{数据3，数据4}};
// 数据类型 数组名[行数][列数] = {数据1，数据2，数据3，数据4};
// 数据类型 数组名[][列数] = {数据1，数据2，数据3，数据4}
//建议：以上4种定义方式，利用第二种更加直观，提高代码可读性

//int main()
//{
//	// 数据类型 数组名[行数][列数];
//	//int arr[2][3];//没初始化
//	//arr[0][0] = 1;
//	//arr[0][1] = 2;
//	//arr[0][2] = 3;
//	//arr[1][0] = 4;
//	//arr[1][1] = 5;
//	//arr[1][2] = 6;
//	//int len = sizeof(arr) / sizeof(arr[0][1]);
//	//for (int i = 0; i < 2; i++)
//	//{
//	//	for (int j = 0; j < 3; j++)
//	//	{
//	//		printf("%d ", arr[i][j]);
//	//	}
//	//	printf("\n");
//	//}
//
//	// 数据类型 数组名[行数][列数] = {{数据1，数据2}{数据3，数据4}};
//	//int arr[2][3] =
//	//{
//	//	{1,2,3},
//	//	{4,5,6}
//	//};//这样写很直观,且初始化
//	//for (int i = 0; i < 2; i++)
//	//{
//	//	for (int j = 0; j < 3; j++)
//	//	{
//	//		printf("%d ", arr[i][j]);
//	//	}
//	//	printf("\n");
//	//}
//
//	// 数据类型 数组名[行数][列数] = {数据1，数据2，数据3，数据4};
//	//int arr[2][3] ={1,2,3,4,5,6};//与第二种没区别就是可读性的问题，计算机看这个和第二个没区别
//	//for (int i = 0; i < 2; i++)
//	//{
//	//	for (int j = 0; j < 3; j++)
//	//	{
//	//		printf("%d ", arr[i][j]);
//	//	}
//	//printf("\n");
//	//}
//	
//	// 数据类型 数组名[][列数] = {数据1，数据2，数据3，数据4}
//	//列数不能省去，行数可以。这个是数组的存储形式。数组是连续存储的，只有下标不同。可以看成二维表，列才是真正的元素
//	int arr[][3] = { 1,2,3,4,5,6 };//因为电脑会可以分辨每三列为一行。而且二维数组也是数组，也是连续存储的没有一二维之分，只有下标不同。
//	for (int i = 0; i < 2; i++)
//	{
//		for (int j = 0; j < 3; j++)
//		{
//			printf("%d ", arr[i][j]);
//		}
//	printf("\n");
//	}
//	system("pause");
//	return 0;
//}

//二维数组名称
// 查看二维数组所占内存空间
// 获取二维数组首地址

//int main()
//{
//	//二维数组名称用途
//
//	//1.可以查看占用内存空间大小
//	int arr[2][3] =
//	{
//		{1,2,3},
//		{4,5,6}
//	};
//	cout << "占空间大小 = " << sizeof(arr) << endl;
//	cout << "一行占空间大小 = " << sizeof(arr[0]) << endl;
//	cout << "第一个元素占空间大小 = " << sizeof(arr[0][0]) << endl;
//	cout << "行数为 = " << sizeof(arr) / sizeof(arr[0]) << endl;
//	//列没有办法，但可以用数学公式求出来
//	cout << "列数为 = " << sizeof(arr[0]) / sizeof(arr[0][0]) << endl;
//
//	//2.可以查看二维数组的首地址
//	//查看元素地址要&号，行列不需要，可以吧二维数组看成N(N是N行)的一维数组
//	cout << "二维数组首地址为 = " << arr << endl;
//	cout << "二维数组第一行地址为 = " << arr[0] << endl;
//	cout << "二维数组第二行地址为 = " << arr[1] << endl;
//	cout << "二维数组第一个元素地址为 = " << &arr[0][0] << endl;
//	cout << "二维数组第二个元素地址为 = " << &arr[0][1] << endl;
//
//	system("pause");
//	return 0;
//}

//二维数组案例
//考试成绩统计

//int main()
//{
//	int arr[3][3] =
//	{
//		{100,100,100},
//		{90,50,100},
//		{60,70,80}
//	};
//	string name[] = { "张三","李四","王五" };
//	int hang = sizeof(arr) / sizeof(arr[0]);
//	int lie = sizeof(arr[0]) / sizeof(arr[0][0]);
//	for (int i = 0; i < hang; i++)
//	{
//		int a = 0;
//		cout << name[i]<<": ";
//
//		for (int j = 0; j < lie; j++)
//		{
//			printf("%d ", arr[i][j]);
//			a += arr[i][j];
//		}
//		cout << "=" << a << endl;
//	}
//
//	system("pause");
//	return 0;
//}
