#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string>
#include <iostream>
using namespace std;

//继承同名静态成员处理方式(和同名成员一样就是和上节课一样)
// 问题继承中的静态成员在子类对象上如何进行访问的
// 静态成员和非静态成员出现同名，处理方式一致
// 访问子类同名成员 直接访问即可
// 访问父类同名成员 需要加作用域
//总结:同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式(通过对象 和 通过类名)

//class Base
//{
//public:
//	Base();
//	~Base();
//	
//	static void func()
//	{
//
//		cout << "base func" << endl;
//	}
//
//	static void func(int a)
//	{
//
//		cout << "base func(int a)" << endl;
//	}
//
//	static int m_A;
//
//private:
//
//};
//
//Base::Base()
//{
//}
//
//Base::~Base()
//{
//}
//
//int Base::m_A = 100;
//
//class Son :public Base
//{
//public:
//
//	static void func()
//	{
//
//		cout << "son func" << endl;
//	}
//
//	static int m_A;
//
//};
//int Son::m_A = 200;
//
//void test01()
//{
//	//同名的静态属性
//	//通过对象访问
//	printf("通过对象访问\n");
//	Son s;
//	cout << "son m_A = " << s.m_A << endl;
//	cout << "base m_A = " << s.Base::m_A << endl;
//
//	//通过类名访问
//	printf("通过类名访问\n");
//	cout << "son m_A = " << Son::m_A << endl;
//	cout << "base m_A = " << Base::m_A << endl;//这个是直接从父类拿到
//	//第一个::代表通过类名方式访问 第二个::代表访问父类作用域下
//	cout << "base m_A = " << Son::Base::m_A << endl;
//
//	//同名的静态函数
//	//通过对象访问
//	printf("通过对象访问\n");
//	printf("\n");
//	s.func();
//	s.Base::func();
//
//	//通过类名
//	printf("通过类名访问\n");
//	Son::func();
//	Son::Base::func();
//
//	//子类出现和父类同名的静态成员函数，也会隐藏父类中所有同名成员函数
//	//如果想访问父类中被隐藏同名成员，需要加作用域
//	//Son::func(10);
//	Son::Base::func(10);
//}
//
//int main()
//{
//	test01();
//
//	system("pause");
//	return 0;
//}

//多继承语法
// C++允许一个类继承多个类
// 语法:class 子类 :继承方式 父类1, 继承方式 父类2...
// 多继承可能会引发父类中有同名成员出现，需要加作用域区分
// C++实际开发中不建议使用多继承
//总结:多继承中如果父类中出现了同名情况，子类使用时候要加作用域

//class Base
//{
//public:
//	Base();
//	~Base();
//	
//	int m_A;
//private:
//
//};
//
//Base::Base()
//{
//	m_A = 100;
//}
//
//Base::~Base()
//{
//}
//
//class Base2
//{
//public:
//	Base2();
//	~Base2();
//
//	int m_A;
//private:
//
//};
//
//Base2::Base2()
//{
//	m_A = 200;
//}
//
//Base2::~Base2()
//{
//}
//
////子类 需要继承base1和base2
//// 语法:class 子类 :继承方式 父类1, 继承方式 父类2...
//class Son :public Base, public Base2
//{
//public:
//	Son()
//	{
//		m_C = 300;
//		m_D = 400;
//	}
//	int m_C;
//	int m_D;
//};
//
//void test01()
//{
//	Son s;
//	cout << "sizeof = " << sizeof(s) << endl;//全部都加起来
//	//如果父类2的m_B变成m_A编译器那会报错,当父类冲出现重名的成员，需要加作用域
//	//cout << "m_A = " << s.m_A << endl;
//	cout << "m_A = " << s.Base::m_A << endl;
//	cout << "m_A = " << s.Base2::m_A << endl;
//
//}
//
//int main()
//{
//	test01();
//
//	system("pause");
//	return 0;
//}

//菱形继承
// 菱形继承概念
// 两个派生类继承同一个基类
// 又有某个类同时继承者两个派生类
// 这种继承被称为菱形继承，或者钻石继承
// 
// 菱形继承的问题{(动物)(羊)(驼)(羊驼)}
// 羊继承了动物的数据，驼同样继承了动物的数据，当羊驼使用数据时，就会产生二义性
// 羊驼继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以
// 总结:菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义
// 利用虚继承可以解决菱形继承问题
//

//动物类
class Animal
{
public:
	Animal();
	~Animal();

	int m_age;

private:

};

Animal::Animal()
{
}

Animal::~Animal()
{
}

//利用虚继承 解决菱形继承的问题
// 在继承之前 加上关键字 virtual 变为虚继承
// Animal类称为 虚基类(类似共享) = virtual会指向一个虚基表，表里有偏移量，偏移量和前面的数相加就是这个唯一的属性 
//羊类
class Sheep :virtual public Animal
{

};

//驼类
class Camle :virtual public Animal
{

};

//羊驼类
class SheepTuo :public Sheep, public Camle
{


};

void test01()
{
	SheepTuo st;
	st.Sheep::m_age = 18;
	st.Camle::m_age = 28;
	//菱形继承，两个父类拥有相同的数据，需要加以作用域区分
	cout << "st.sheep::m_age = " << st.Sheep::m_age << endl;
	cout << "st.camle::m_age = " << st.Camle::m_age << endl;
	cout << "st.m_age = " << st.m_age << endl;

	//这份数据我们知道 只有一份就可以了，菱形继承导致了数据有两份，资源浪费
	//利用虚继承 解决菱形继承的问题
}

int main()
{
	test01();

	system("pause");
	return 0;
}
